# 优雅停机

Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果用户使用 kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。

# 原理

## 服务提供方

停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。
然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。

## 服务消费方

停止时，不再发起新的调用请求，所有新的调用在客户端即报错。

然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。

## 设置方式

设置优雅停机超时时间，缺省超时时间是 10 秒，如果超时则强制关闭。

```
# dubbo.properties
dubbo.service.shutdown.wait=15000
```

如果 ShutdownHook 不能生效，可以自行调用，使用tomcat等容器部署的場景，建议通过扩展ContextListener等自行调用以下代码实现优雅停机：

```java
ProtocolConfig.destroyAll();
```

# 注册中心

本期不考虑。

# 服务端

## 服务启动

（1）连接池信息。

## 关闭时的处理

通过 shut down hook 管理对应的信息。

volatile status 状态管理，如果 shutdown 则通知所有的 service 标志位不可用。

status=0 初始化

status=1 可用

status=2 开始关闭

status=3 正常关闭完成

status=4 超时关闭完成

（1）是否有请求在处理中。

服务端也应该有一个 reqInvokeService 管理请求信息。

（2）接收到新的请求，直接抛出异常，不可用。

（3）超时检测

为了避免 shutdown 时间过长，可以为其设置一个 timeout=60s 默认可以为 1min

超时之后，直接强制中断。

===========================

# 客户端

## 新建一个实例

### 初始化

- 管理对应的连接池信息

状态和服务端保持一致。

### 关闭时

（1）设置状态为不可用

（2）如果再有请求，直接失败

（3）检查所有的 invoke 完成。

设置对应的超时时间，如果超时直接中断。

